class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;

        int next1 = cost[n - 1];
        int next2 = 0;

        for (int i = n - 2; i >= 0; i--) {
            int curr = cost[i] + Math.min(next1, next2);
            next2 = next1;
            next1 = curr;
        }
        return Math.min(next1, next2);
    }
}


        // BOTTOM - UP  APPROACH =>
        // int n = cost.length;
        // int[] dp = new int[n + 1];

        // dp[n] = 0;
        // dp[n - 1] = cost[n - 1];

        // for (int i = n - 2; i >= 0; i--) {
        //     dp[i] = cost[i] + Math.min(dp[i + 1], dp[i + 2]);
        // }
        // return Math.min(dp[0], dp[1]);




        // TOP - DOWN APPROACH =>
        // int n = cost.length;
        // int[] dp = new int[n];
        // Arrays.fill(dp, -1);
        // return Math.min(solve(0, cost, dp), solve(1, cost, dp));
        // }
        // private int solve(int i, int[] cost, int[] dp) {
        // int n = cost.length;

        // if (i >= n) return 0;
        // if (dp[i] != -1) return dp[i];

        // int oneStep = solve(i + 1, cost, dp);
        // int twoStep = solve(i + 2, cost, dp);

        // dp[i] = cost[i] + Math.min(oneStep, twoStep);
        // return dp[i];


        // Recursion Approach =>
        //  int n = cost.length;
        // return Math.min(solve(0, cost), solve(1, cost));
        // }
        // private int solve(int i, int[] cost) {
        // int n = cost.length;

        // if (i >= n) return 0;

        // int oneStep = solve(i + 1, cost);
        // int twoStep = solve(i + 2, cost);

        // return cost[i] + Math.min(oneStep, twoStep);


